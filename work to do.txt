work to do:
- backend:
    - process different types of data: 
        - problem-related: 
            - vehicle-only: to terminate/create corresponding das (those which names already in the list be kept intact, not on the list will be terminated, on the list but not initiated will be initiated)
            - customer-only: use the existing list of das to solve the problem
        - agent-related:
            - da: state should be passed to some api to update the state on the website
    - there should be separate apis for these datas

- agent:
    - da:
        - if mra trying to query when some das are delivering, they may response busy
        - states are busy and free (busy when delivering, free when at/arrived back to the depot position)
        - when arrived back to the depot, must notify the depot (depot do not need to response back) (this conversation need to be logged)
    - main:
        - based on the type of data from api to terminate, start, or do nothing to the das

- frontend:
    - vehicle page:
        - still current setting, but now on change will send vehicle-only data to the api (also force the user to confirm change on exit page)
        - have a "save" button along with other neccessary buttons
    - main page:
        - request now not contain vehicle list anymore
    - test cases:
        - choosing test cases prompt the user to the vehicle page and force them to confirm changes before view the user data in the main page

current problem:
    - choosing test cases will create more agents then call all those agents to solve the problem, which should not be
    - request the same problem again and again

delete all current test cases in frontend
vehicle agents should have a list of assigned routes from the mra
- have 3 test cases:
    - test case 1: basic agent communication (basic cvrp)
        - all customers must be served in one go
        - mra: receive request, ask for capacity, assign route
        - da: return capacity, receive route, execute the route (or store for later execution), notify the depot when came back

    - test case 2: demand exceed capacity (test favor item over distance)
        - mra: like test case 1, but now with unserved customer which will be stored
        - da: like test case 1
        - after solving the first round, the unserved customer will be taken to solved again and assign back to the das, which will store the new route and execute later

    - test case 3: with maximum distance
        - like test case 1, but now with max distance

    - test case 4: multiple request when das have not arrived back
        - combination of all the above test cases, but now mra store unserved nodes in a separate list, until reached 6 (or no more requests left), take out for processing (before process the next request)

    - test case 5: with time window
        - mra: ask for capacity, speed, and maximum distance, assign route
        - da: now 

if test-case: send vehicle data along with route data, mra only ask for the presence of those vehicles
if normal: send customer data only, mra queries all vehicle to solve the problem
adjust vehicle list: will send the vehicle list only for main to send terminate request/create to match the list

new frontend (in python completely) (implement in "frontend 2" folder):
- load logs of agents in execution
- visualize movement of das when executing route
- load test cases (scenarios), pass to the backend, and visualize it
- let the user to pick nodes with demand

current implementation:
- just let the mra receive request directly from the frontend (customer only list)
- vehicle only list will be sent to the main to terminate/create da agents

final res:
a website that:
- let user define vehicles ONCE
- define customers and their demands
- view information about the agents, their logs
- visualize the routes and the movement of vehicles on the solved routes
- visualization of unserved customers, how those are taken into the next request/solve independently
- visualization of logs

detailed:
- requests only send customer info as all agents are defined at first to be initiated by the main
- make use of the current apis and implement more if needed
- the depot location is 0,0 but make it in the middle of the visual map